import torch
import os
import random
import sys

# ç¡®ä¿èƒ½æ‰¾åˆ° src æ¨¡å—
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.join(current_dir, "..")
if project_root not in sys.path:
    sys.path.append(project_root)

from src.dataset import EmotionSegmentDataset
from src.model import DynamicEmotionModel

# ================= é…ç½® =================
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
WAVLM_PATH = "pretrained/wavlm.pt"
MODEL_PATH = "models/best_model.pth"
# =======================================

def denormalize(val):
    """æŠŠ 0-1 çš„é¢„æµ‹å€¼è¿˜åŸå› 1-5"""
    return val * 4.0 + 1.0

def inference():
    print("ğŸš€ å¼€å§‹æ¨ç†è„šæœ¬...", flush=True)
    
    # 1. åŠ è½½éªŒè¯é›†
    val_csv = "data/val.csv"
    if not os.path.exists(val_csv):
        print(f"âŒ æ‰¾ä¸åˆ°éªŒè¯é›†æ–‡ä»¶: {val_csv}")
        return

    print(f"æ­£åœ¨åŠ è½½éªŒè¯é›†: {val_csv} ...")
    try:
        val_ds = EmotionSegmentDataset(val_csv, project_root=".")
        print(f"éªŒè¯é›†å¤§å°: {len(val_ds)}")
    except Exception as e:
        print(f"âŒ æ•°æ®é›†åŠ è½½å¤±è´¥: {e}")
        return
    
    if len(val_ds) == 0:
        print("âŒ éªŒè¯é›†ä¸ºç©ºï¼")
        return

    # 2. åŠ è½½æ¨¡å‹
    if not os.path.exists(MODEL_PATH):
        print(f"âŒ æ‰¾ä¸åˆ°æ¨¡å‹æ–‡ä»¶: {MODEL_PATH}")
        return

    print(f"æ­£åœ¨åŠ è½½æ¨¡å‹: {MODEL_PATH} ...")
    try:
        model = DynamicEmotionModel(wavlm_path=WAVLM_PATH).to(DEVICE)
        model.load_state_dict(torch.load(MODEL_PATH, map_location=DEVICE))
        model.eval()
    except Exception as e:
        print(f"âŒ æ¨¡å‹åŠ è½½å¤±è´¥: {e}")
        return
    
    print("-" * 75)
    print(f"{'çœŸå®å€¼ (A/V/D)':<25} | {'é¢„æµ‹å€¼ (A/V/D)':<25} | {'è¯¯å·®':<10}")
    print("-" * 75)

    # 3. éšæœºæŠ½å–æ ·æœ¬è¿›è¡Œæµ‹è¯•
    sample_count = min(10, len(val_ds))
    indices = random.sample(range(len(val_ds)), sample_count)
    
    total_error = 0
    with torch.no_grad():
        for idx in indices:
            wav, label = val_ds[idx]
            
            if wav.sum() == 0:
                print(f"{'âš ï¸ åæ•°æ® (è·³è¿‡)':<25} | {'---':<25} | ---")
                continue

            wav = wav.unsqueeze(0).to(DEVICE)
            
            # é¢„æµ‹
            pred = model(wav).cpu().squeeze(0)
            
            # åå½’ä¸€åŒ–
            true_score = denormalize(label)
            pred_score = denormalize(pred)
            
            # æ ¼å¼åŒ–è¾“å‡º
            t_str = f"{true_score[0]:.1f}, {true_score[1]:.1f}, {true_score[2]:.1f}"
            p_str = f"{pred_score[0]:.1f}, {pred_score[1]:.1f}, {pred_score[2]:.1f}"
            
            err = (true_score - pred_score).abs().mean().item()
            total_error += err
            
            print(f"{t_str:<25} | {p_str:<25} | {err:.2f}")

    print("-" * 75)
    print(f"å¹³å‡è¯¯å·®: {total_error/sample_count:.4f}")

if __name__ == "__main__":
    inferencme
